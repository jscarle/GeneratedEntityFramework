using System.Collections.Immutable;
using System.Text;
using GeneratedEntityFramework.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GeneratedEntityFramework;

[Generator]
public sealed class EntityFrameworkGenerator : IIncrementalGenerator
{
    private const string BaseNamespace = "GeneratedEntityFramework";
    internal const string AttributesHint = $"{BaseNamespace}.Attributes.g.cs";
    private const string RegistrationClassName = "RegisterServices";
    internal const string RegistrationClassHint = $"{BaseNamespace}.{RegistrationClassName}.g.cs";
    private const string RegistrationMethodName = "AddDbContextInterfaces";
    private const string DbContextAttributeName = "DbContextAttribute";
    private const string DbContextAttributeFullyQualifiedName = $"{BaseNamespace}.{DbContextAttributeName}";
    private const string GeneratedDbContextAttributeName = "GeneratedDbContextAttribute";
    private const string GeneratedDbContextAttributeFullyQualifiedName = $"{BaseNamespace}.{GeneratedDbContextAttributeName}";
    private const string DbContextInterfaceLifetimeAttributeName = "DbContextInterfaceLifetimeAttribute";
    private const string AsNoTrackingAttributeName = "AsNoTrackingAttribute";
    private const string DbSetBackingFieldPrefix = "DbSet__";

    private static readonly string FileHeader = $"""
                                                 //-----------------------------------------------------------------------------
                                                 // <auto-generated>
                                                 // This code was generated by {nameof(EntityFrameworkGenerator)} which can be found
                                                 // in the {typeof(EntityFrameworkGenerator).Namespace} namespace.
                                                 //
                                                 // Changes to this file may cause incorrect behavior
                                                 // and will be lost if the code is regenerated.
                                                 // </auto-generated>
                                                 //-----------------------------------------------------------------------------
                                                 #nullable enable
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(RegisterAttributes);

        var genericDbContexts = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{DbContextAttributeFullyQualifiedName}`1",
            FilterDbContextAttribute,
            TransformDbContextAttribute
        ).WhereNotNull().Collect();
        var nonGenericDbContexts = context.SyntaxProvider.ForAttributeWithMetadataName(
            DbContextAttributeFullyQualifiedName,
            FilterDbContextAttribute,
            TransformDbContextAttribute
        ).WhereNotNull().Collect();
        var genericGeneratedDbContexts = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{GeneratedDbContextAttributeFullyQualifiedName}`1",
            FilterGeneratedDbContextAttribute,
            TransformGeneratedDbContextAttribute
        ).WhereNotNull().SelectMany((x, _) => x).Collect();
        var nonGenericGeneratedDbContexts = context.SyntaxProvider.ForAttributeWithMetadataName(
            GeneratedDbContextAttributeFullyQualifiedName,
            FilterGeneratedDbContextAttribute,
            TransformGeneratedDbContextAttribute
        ).WhereNotNull().SelectMany((x, _) => x).Collect();
        var combinedDbContexts = genericDbContexts.Combine(nonGenericDbContexts, genericGeneratedDbContexts, nonGenericGeneratedDbContexts);

        context.RegisterSourceOutput(combinedDbContexts, GenerateSource);
    }

    private static bool FilterDbContextAttribute(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return syntaxNode is InterfaceDeclarationSyntax;
    }

    private static GeneratedDbContext? TransformDbContextAttribute(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (!IsValidDbContextAttribute(context, out var dbContextSymbol, out var interfaceSymbol))
            return null;

        var dbContext = GetDbContext(dbContextSymbol, cancellationToken);
        var dbContextInterface = GetInterface(interfaceSymbol, cancellationToken);

        return new GeneratedDbContext(dbContext, dbContextInterface);
    }

    private static bool FilterGeneratedDbContextAttribute(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return syntaxNode is ClassDeclarationSyntax;
    }

    private static ImmutableArray<GeneratedDbContext>? TransformGeneratedDbContextAttribute(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken
    )
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (!IsValidGeneratedDbContextAttribute(context, out var dbContextSymbol, out var interfaceSymbols))
            return null;

        var generatedDbContexts = new List<GeneratedDbContext>();

        var dbContext = GetDbContext(dbContextSymbol, cancellationToken);

        foreach (var dbContextInterface in dbContext.Interfaces)
        {
            var generatedDbContext = new GeneratedDbContext(dbContext, dbContextInterface);
            generatedDbContexts.Add(generatedDbContext);
        }

        foreach (var interfaceSymbol in interfaceSymbols)
        {
            var dbContextInterface = GetInterface(interfaceSymbol, cancellationToken);
            var generatedDbContext = new GeneratedDbContext(dbContext, dbContextInterface);
            generatedDbContexts.Add(generatedDbContext);
        }

        return generatedDbContexts.ToImmutableArray();
    }

    private static bool IsValidDbContextAttribute(
        GeneratorAttributeSyntaxContext context,
        out INamedTypeSymbol dbContextSymbol,
        out INamedTypeSymbol interfaceSymbol
    )
    {
        if (context.TargetSymbol is INamedTypeSymbol targetSymbol)
        {
            if (context.Attributes is [{ AttributeClass.TypeArguments: [INamedTypeSymbol typeArgument] }])
            {
                dbContextSymbol = typeArgument;
                interfaceSymbol = targetSymbol;
                return true;
            }

            if (context.Attributes is [{ ConstructorArguments: [{ Value: INamedTypeSymbol constructorArgument }] }] && IsDbContextSymbol(constructorArgument))
            {
                dbContextSymbol = constructorArgument;
                interfaceSymbol = targetSymbol;
                return true;
            }
        }

        dbContextSymbol = default!;
        interfaceSymbol = default!;
        return false;
    }

    private static bool IsValidGeneratedDbContextAttribute(
        GeneratorAttributeSyntaxContext context,
        out INamedTypeSymbol dbContextSymbol,
        out ImmutableArray<INamedTypeSymbol> interfaceSymbols
    )
    {
        if (context.TargetSymbol is INamedTypeSymbol targetSymbol && IsDbContextSymbol(targetSymbol))
        {
            var matchedSymbols = ImmutableArray.CreateBuilder<INamedTypeSymbol>();
            foreach (var attribute in context.Attributes)
            {
                if (attribute is { AttributeClass.TypeArguments: [INamedTypeSymbol typeArgument] })
                    matchedSymbols.Add(typeArgument);

                if (attribute is { ConstructorArguments: [{ Value: INamedTypeSymbol constructorArgument }] })
                    matchedSymbols.Add(constructorArgument);
            }
            dbContextSymbol = targetSymbol;
            interfaceSymbols = matchedSymbols.ToImmutable();
            return true;
        }

        dbContextSymbol = default!;
        interfaceSymbols = default;
        return false;
    }

    private static bool IsDbContextSymbol(INamedTypeSymbol type)
    {
        return type.BaseType switch
        {
            null => false,
            {
                Name: "DbContext",
                ContainingNamespace: { Name: "EntityFrameworkCore", ContainingNamespace: { Name: "Microsoft", ContainingNamespace.IsGlobalNamespace: true } },
            } => true,
            _ => IsDbContextSymbol(type.BaseType),
        };
    }

    private static DbContext GetDbContext(INamedTypeSymbol symbol, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var ns = symbol.ContainingNamespace.IsGlobalNamespace ? "" : symbol.ContainingNamespace.ToDisplayString();
        var name = symbol.Name;
        var type = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var accessibility = symbol.DeclaredAccessibility;
        var interfaces = symbol.AllInterfaces.Where(
            x => x is not
            {
                ContainingNamespace: { Name: "System", ContainingNamespace.IsGlobalNamespace: true },
            } && x is not
            {
                ContainingNamespace: { Name: "Microsoft", ContainingNamespace.IsGlobalNamespace: true },
            }
        ).Select(x => GetInterface(x, cancellationToken)).Where(x => x.Properties.Count > 0).ToEquatableImmutableArray();

        var serviceLifetime = ServiceLifetime.Scoped;
        var attributes = symbol.GetAttributes();
        if (attributes is
            [
                {
                    AttributeClass:
                    {
                        Name: DbContextInterfaceLifetimeAttributeName,
                        ContainingNamespace: { Name: BaseNamespace, ContainingNamespace.IsGlobalNamespace: true },
                    },
                    ConstructorArguments: [{ Value: int serviceLifetimeValue and >= 0 and <= 2 }],
                },
            ])
            serviceLifetime = (ServiceLifetime)serviceLifetimeValue;

        return new DbContext(ns, name, type, accessibility, serviceLifetime, interfaces);
    }

    private static Interface GetInterface(INamedTypeSymbol symbol, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var ns = symbol.ContainingNamespace.IsGlobalNamespace ? "" : symbol.ContainingNamespace.ToDisplayString();
        var name = symbol.Name;
        var type = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var accessibility = symbol.DeclaredAccessibility;
        var properties = GetProperties(symbol, cancellationToken);

        return new Interface(ns, name, type, accessibility, properties);
    }

    private static EquatableImmutableArray<Property> GetProperties(INamedTypeSymbol interfaceSymbol, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var properties = ImmutableArray.CreateBuilder<Property>();

        foreach (var member in interfaceSymbol.GetMembers())
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (IsDbSetProperty(member, out var dbSetProperty, out var dbSetArgument))
            {
                var property = GetProperty(PropertyType.DbSet, dbSetProperty, dbSetArgument);
                properties.Add(property);
            }

            if (IsIQueryableProperty(member, out var iQueryableProperty, out var iQueryableArgument))
            {
                var property = GetProperty(PropertyType.IQueryable, iQueryableProperty, iQueryableArgument);
                properties.Add(property);
            }
        }

        return properties.ToEquatableImmutable();
    }

    private static bool IsDbSetProperty(ISymbol member, out IPropertySymbol dbSetProperty, out INamedTypeSymbol dbSetArgument)
    {
        if (member is IPropertySymbol
            {
                GetMethod.ReturnType: INamedTypeSymbol
                {
                    MetadataName: "DbSet`1",
                    ContainingNamespace:
                    { Name: "EntityFrameworkCore", ContainingNamespace: { Name: "Microsoft", ContainingNamespace.IsGlobalNamespace: true } },
                    TypeArguments: [INamedTypeSymbol dbSetArgumentSymbol],
                },
            } dbSetPropertySymbol)
        {
            dbSetProperty = dbSetPropertySymbol;
            dbSetArgument = dbSetArgumentSymbol;
            return true;
        }

        dbSetProperty = default!;
        dbSetArgument = default!;
        return false;
    }

    private static bool IsIQueryableProperty(ISymbol member, out IPropertySymbol iQueryableProperty, out INamedTypeSymbol iQueryableArgument)
    {
        if (member is IPropertySymbol
            {
                GetMethod.ReturnType: INamedTypeSymbol
                {
                    MetadataName: "IQueryable`1",
                    ContainingNamespace: { Name: "Linq", ContainingNamespace: { Name: "System", ContainingNamespace.IsGlobalNamespace: true } },
                    TypeArguments: [INamedTypeSymbol iQueryableArgumentSymbol],
                },
            } iQueryablePropertySymbol)
        {
            iQueryableProperty = iQueryablePropertySymbol;
            iQueryableArgument = iQueryableArgumentSymbol;
            return true;
        }

        iQueryableProperty = default!;
        iQueryableArgument = default!;
        return false;
    }

    private static Property GetProperty(PropertyType type, IPropertySymbol property, INamedTypeSymbol propertyArgument)
    {
        var name = property.Name;
        var argument = propertyArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var accessibility = property.DeclaredAccessibility;

        var asNoTracking = false;
        if (type != PropertyType.IQueryable)
            return new Property(name, type, argument, accessibility, asNoTracking);

        var attributes = property.GetAttributes();
        asNoTracking = attributes is
        [
            {
                AttributeClass:
                {
                    Name: AsNoTrackingAttributeName, ContainingNamespace: { Name: BaseNamespace, ContainingNamespace.IsGlobalNamespace: true },
                },
            },
        ];

        return new Property(name, type, argument, accessibility, asNoTracking);
    }

    private static void RegisterAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        var source = $$"""
                       {{FileHeader}}

                       namespace {{BaseNamespace}}
                       {

                       #if NET7_0_OR_GREATER

                           /// <summary>
                           /// Marks an interface as being associated with a <see cref="Microsoft.EntityFrameworkCore.DbContext"/> of type
                           /// <typeparamref name="TDbContext"/>.
                           /// </summary>
                           /// <typeparam name="TDbContext">
                           /// The type of the <see cref="Microsoft.EntityFrameworkCore.DbContext"/> associated with the marked interface.
                           /// </typeparam>
                           /// <remarks>
                           /// This attribute is used by the Entity Framework source generator to identify interfaces that should have corresponding
                           /// <see cref="Microsoft.EntityFrameworkCore.DbContext"/> implementations generated.
                           /// </remarks>
                           [global::System.AttributeUsage(global::System.AttributeTargets.Interface, AllowMultiple = true)]
                           public sealed class {{DbContextAttributeName}}<TDbContext> : global::System.Attribute
                               where TDbContext : global::Microsoft.EntityFrameworkCore.DbContext
                           {
                           }

                           /// <summary>
                           /// Marks a <see cref="Microsoft.EntityFrameworkCore.DbContext"/> as being associated with an interface.
                           /// </summary>
                           /// <typeparam name="TInterface">
                           /// The type of the interface associated with the marked <see cref="Microsoft.EntityFrameworkCore.DbContext"/>.
                           /// </typeparam>
                           /// <remarks>
                           /// This attribute is used by the Entity Framework source generator to identify interfaces that should have corresponding
                           /// <see cref="Microsoft.EntityFrameworkCore.DbContext"/> implementations generated.
                           /// </remarks>
                           [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = true)]
                           public sealed class {{GeneratedDbContextAttributeName}}<TInterface> : global::System.Attribute
                           {
                           }

                       #endif

                           /// <summary>
                           /// Marks an interface as being associated with a <see cref="Microsoft.EntityFrameworkCore.DbContext"/>.
                           /// </summary>
                           /// <remarks>
                           /// This attribute is used by the Entity Framework source generator to identify interfaces that should have corresponding
                           /// <see cref="Microsoft.EntityFrameworkCore.DbContext"/> implementations generated.
                           /// </remarks>
                           [global::System.AttributeUsage(global::System.AttributeTargets.Interface, AllowMultiple = true)]
                           public sealed class {{DbContextAttributeName}} : global::System.Attribute
                           {
                               /// <summary>
                               /// Gets the type of the <see cref="Microsoft.EntityFrameworkCore.DbContext"/> associated with the marked interface.
                               /// <summary>
                               public global::System.Type DbContextType { get; }

                               /// <summary>Initializes a new instance of the <see cref="{{DbContextAttributeName}}"/> attribute.</summary>
                               /// <param name="dbContextType">
                               /// The type of the <see cref="Microsoft.EntityFrameworkCore.DbContext"/> associated with the marked interface.
                               /// </param>
                               public {{DbContextAttributeName}}(global::System.Type dbContextType)
                               {
                                   DbContextType = dbContextType;
                               }
                           }

                           /// <summary>
                           /// Marks a <see cref="Microsoft.EntityFrameworkCore.DbContext"/> as being associated with an interface.
                           /// </summary>
                           /// <remarks>
                           /// This attribute is used by the Entity Framework source generator to identify interfaces that should have corresponding
                           /// <see cref="Microsoft.EntityFrameworkCore.DbContext"/> implementations generated.
                           /// </remarks>
                           [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = true)]
                           public sealed class {{GeneratedDbContextAttributeName}} : global::System.Attribute
                           {
                               /// <summary>
                               /// Gets the type of the interface associated with the marked <see cref="Microsoft.EntityFrameworkCore.DbContext"/>.
                               /// <summary>
                               public global::System.Type? InterfaceType { get; }

                               /// <summary>Initializes a new instance of the <see cref="{{GeneratedDbContextAttributeName}}"/> attribute.</summary>
                               public {{GeneratedDbContextAttributeName}}()
                               {
                                   InterfaceType = null;
                               }

                               /// <summary>Initializes a new instance of the <see cref="{{GeneratedDbContextAttributeName}}"/> attribute.</summary>
                               /// <param name="interfaceType">
                               /// The type of the interface associated with the marked <see cref="Microsoft.EntityFrameworkCore.DbContext"/>.
                               /// </param>
                               public {{GeneratedDbContextAttributeName}}(global::System.Type interfaceType)
                               {
                                   InterfaceType = interfaceType;
                               }
                           }

                           /// <summary>
                           /// Configures the service lifetime of interfaces associated with the marked <see cref="Microsoft.EntityFrameworkCore.DbContext"/>.
                           /// </summary>
                           /// <remarks>
                           /// This attribute is used by the Entity Framework source generator to configure the service lifetime of all interfaces that have
                           /// corresponding <see cref="Microsoft.EntityFrameworkCore.DbContext"/> implementations generated.
                           /// </remarks>
                           [global::System.AttributeUsage(global::System.AttributeTargets.Class)]
                           public sealed class {{DbContextInterfaceLifetimeAttributeName}} : global::System.Attribute
                           {
                               /// <summary>
                               /// Gets the service lifetime of interfaces associated with the marked <see cref="Microsoft.EntityFrameworkCore.DbContext"/>.
                               /// <summary>
                               public global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; }

                               /// <summary>Initializes a new instance of the <see cref="{{DbContextInterfaceLifetimeAttributeName}}"/> attribute.</summary>
                               /// <param name="serviceLifetime">
                               /// The service lifetime of interfaces associated with the marked <see cref="Microsoft.EntityFrameworkCore.DbContext"/>.
                               /// </param>
                               public {{DbContextInterfaceLifetimeAttributeName}}(global::Microsoft.Extensions.DependencyInjection.ServiceLifetime serviceLifetime)
                               {
                                   ServiceLifetime = serviceLifetime;
                               }
                           }

                           /// <summary>
                           /// Used to indicate that either all properties or a specific property of an interface should be generated with the
                           /// <see cref="System.Linq.IQueryable{T}"/> configured to return entities without tracking.
                           /// </summary>
                           /// <remarks>
                           /// This attribute is used by the Entity Framework source generator to configure the generated
                           /// <see cref="System.Linq.IQueryable{T}"/> properties of an interface to return entities without being tracked by the
                           /// <see cref="Microsoft.EntityFrameworkCore.DbContext"/>. When applied to an interface, all <see cref="System.Linq.IQueryable{T}"/>
                           /// properties of the interface will be configured to return entities without tracking. When applied to a specific property of an
                           /// interface, only that property will be configured accordingly.
                           /// </remarks>
                           [global::System.AttributeUsage(global::System.AttributeTargets.Interface | global::System.AttributeTargets.Property)]
                           public sealed class {{AsNoTrackingAttributeName}} : global::System.Attribute
                           {
                           }
                       }

                       """;

        context.AddSource(AttributesHint, SourceText.From(source, Encoding.UTF8));
    }

    private static void GenerateSource(
        SourceProductionContext context,
        (ImmutableArray<GeneratedDbContext>, ImmutableArray<GeneratedDbContext>, ImmutableArray<GeneratedDbContext>, ImmutableArray<GeneratedDbContext>)
            attributes
    )
    {
        var dbContexts = Merge(attributes);
        foreach (var dbContextGroup in dbContexts.GroupBy(x => x.DbContext.Type))
            GenerateDbContext(context, [.. dbContextGroup]);

        GenerateRegistrationMethod(context, dbContexts);
    }

    private static ImmutableArray<GeneratedDbContext> Merge(
        (ImmutableArray<GeneratedDbContext> A, ImmutableArray<GeneratedDbContext> B, ImmutableArray<GeneratedDbContext> C, ImmutableArray<GeneratedDbContext> D)
            attributes
    )
    {
        var list = new List<GeneratedDbContext>();
        list.AddRange(attributes.A);
        list.AddRange(attributes.B);
        list.AddRange(attributes.C);
        list.AddRange(attributes.D);
        return list.Distinct().ToImmutableArray();
    }

    private static void GenerateDbContext(SourceProductionContext context, IReadOnlyCollection<GeneratedDbContext> dbContexts)
    {
        var dbContext = dbContexts.First();
        var interfaceTypes = dbContexts.Select(x => x.Interface.Type).Where(type => !dbContext.DbContext.Interfaces.Select(x => x.Type).Contains(type))
            .Distinct().ToList();
        var interfaceProperties = dbContexts.SelectMany(
            x => x.Interface.Properties.Select(
                y => new
                {
                    y.Name,
                    y.Type,
                    y.ArgumentType,
                    y.Accessibility,
                    y.AsNoTracking,
                    ParentAccessibility = x.Interface.Accessibility,
                }
            )
        ).Distinct().ToList();
        var dbSetProperties = interfaceProperties.Where(x => x.Type == PropertyType.DbSet).ToList();
        var iQueryableProperties = interfaceProperties.Where(x => x.Type == PropertyType.IQueryable).ToList();

        var source = new StringBuilder();

        source.AppendLine(FileHeader);
        source.AppendLine();

        source.AppendLine("using global::Microsoft.EntityFrameworkCore;");
        source.AppendLine();

        if (dbContext.DbContext.Namespace.Length > 0)
        {
            source.Append("namespace ");
            source.AppendLine(dbContext.DbContext.Namespace);

            source.AppendLine("{");
        }

        source.Append("    ");
        source.Append(AccessibilityKeyword(dbContext.DbContext.Accessibility));
        source.Append(" partial class ");
        source.Append(dbContext.DbContext.Name);
        if (interfaceTypes.Count > 0)
            source.Append(" :");
        var addComma = false;
        foreach (var interfaceType in interfaceTypes)
        {
            if (addComma)
                source.Append(',');
            source.AppendLine();
            source.Append("        ");
            source.Append(interfaceType);
            if (!addComma)
                addComma = true;
        }
        source.AppendLine();

        source.AppendLine("    {");

        foreach (var property in dbSetProperties)
        {
            source.Append("        ");
            source.Append(AccessibilityKeyword(property.Accessibility, property.ParentAccessibility));
            source.Append(' ');
            source.Append(PropertyTypeString(PropertyType.DbSet));
            source.Append('<');
            source.Append(property.ArgumentType);
            source.Append("> ");
            source.Append(property.Name);
            source.Append(" { get; set; } = default!;");
            source.AppendLine();
        }

        var dbSets = new Dictionary<string, string>();
        foreach (var property in iQueryableProperties)
        {
            dbSets.TryGetValue(property.ArgumentType, out var dbSetName);
            if (dbSetName is null)
            {
                var existingDbSets = dbSetProperties.Where(x => x.ArgumentType == property.ArgumentType).ToList();
                if (existingDbSets.Count == 0)
                {
                    dbSetName = $"{DbSetBackingFieldPrefix}{property.Name}";

                    source.Append("        private ");
                    source.Append(PropertyTypeString(PropertyType.DbSet));
                    source.Append('<');
                    source.Append(property.ArgumentType);
                    source.Append("> ");
                    source.Append(dbSetName);
                    source.AppendLine(" { get; set; } = default!;");
                }
                else
                {
                    dbSetName = existingDbSets[0].Name;
                }
                dbSets.Add(property.ArgumentType, dbSetName);
            }

            source.Append("        ");
            source.Append(AccessibilityKeyword(property.Accessibility, property.ParentAccessibility));
            source.Append(' ');
            source.Append(PropertyTypeString(PropertyType.IQueryable));
            source.Append('<');
            source.Append(property.ArgumentType);
            source.Append("> ");
            source.Append(property.Name);
            source.Append(" => ");
            source.Append(dbSetName);
            if (property.AsNoTracking)
                source.Append(".AsNoTracking()");
            source.AppendLine(";");
        }

        source.AppendLine("    }");

        if (dbContext.DbContext.Namespace.Length > 0)
            source.AppendLine("}");

        var hint = $"{(dbContext.DbContext.Namespace.Length > 0 ? $"{dbContext.DbContext.Namespace}" : "")}{dbContext.DbContext.Name}.g.cs";
        context.AddSource(hint, SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static string AccessibilityKeyword(Accessibility accessibility, Accessibility? parentAccessibility = null)
    {
        return accessibility switch
        {
            Accessibility.NotApplicable => parentAccessibility.HasValue ? AccessibilityKeyword(parentAccessibility.Value) : "internal",
            Accessibility.Private => "private",
            Accessibility.ProtectedAndInternal => "protected internal",
            Accessibility.Protected => "protected",
            Accessibility.Internal => "internal",
            Accessibility.ProtectedOrInternal => "internal",
            Accessibility.Public => "public",
            _ => throw new NotImplementedException(),
        };
    }

    private static string PropertyTypeString(PropertyType propertyType)
    {
        return propertyType switch
        {
            PropertyType.DbSet => "global::Microsoft.EntityFrameworkCore.DbSet",
            PropertyType.IQueryable => "global::System.Linq.IQueryable",
            _ => throw new NotImplementedException(),
        };
    }

    private static void GenerateRegistrationMethod(SourceProductionContext context, ImmutableArray<GeneratedDbContext> dbContexts)
    {
        var source = new StringBuilder();

        source.AppendLine(FileHeader);
        source.AppendLine();

        source.AppendLine("using global::Microsoft.Extensions.DependencyInjection;");
        source.AppendLine();

        source.Append("namespace ");
        source.AppendLine(BaseNamespace);

        source.AppendLine("{");

        source.Append("    public static class ");
        source.AppendLine(RegistrationClassName);

        source.AppendLine("    {");

        source.Append("        public static void ");
        source.Append(RegistrationMethodName);
        source.AppendLine("(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");

        source.AppendLine("        {");

        foreach (var dbContext in dbContexts)
        {
            source.Append("            services.Add");
            source.Append(ServiceLifetimeKeyword(dbContext.DbContext.ServiceLifetime));
            source.Append('<');
            source.Append(dbContext.Interface.Type);
            source.Append(">(sp => sp.GetRequiredService<");
            source.Append(dbContext.DbContext.Type);
            source.AppendLine(">());");
        }

        source.AppendLine("        }");

        source.AppendLine("    }");

        source.AppendLine("}");

        context.AddSource(RegistrationClassHint, SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static string ServiceLifetimeKeyword(ServiceLifetime serviceLifetime)
    {
        return serviceLifetime switch
        {
            ServiceLifetime.Singleton => "Singleton",
            ServiceLifetime.Scoped => "Scoped",
            ServiceLifetime.Transient => "Transient",
            _ => throw new NotImplementedException(),
        };
    }

    private readonly record struct GeneratedDbContext(DbContext DbContext, Interface Interface)
    {
        public DbContext DbContext { get; } = DbContext;
        public Interface Interface { get; } = Interface;
    }

    private readonly record struct DbContext(
        string Namespace,
        string Name,
        string Type,
        Accessibility Accessibility,
        ServiceLifetime ServiceLifetime,
        EquatableImmutableArray<Interface> Interfaces
    )
    {
        public string Namespace { get; } = Namespace;
        public string Name { get; } = Name;
        public string Type { get; } = Type;
        public Accessibility Accessibility { get; } = Accessibility;
        public ServiceLifetime ServiceLifetime { get; } = ServiceLifetime;
        public EquatableImmutableArray<Interface> Interfaces { get; } = Interfaces;
    }

    private readonly record struct Interface(
        string Namespace,
        string Name,
        string Type,
        Accessibility Accessibility,
        EquatableImmutableArray<Property> Properties
    )
    {
        public string Namespace { get; } = Namespace;
        public string Name { get; } = Name;
        public string Type { get; } = Type;
        public Accessibility Accessibility { get; } = Accessibility;
        public EquatableImmutableArray<Property> Properties { get; } = Properties;
    }

    private readonly record struct Property(string Name, PropertyType Type, string ArgumentType, Accessibility Accessibility, bool AsNoTracking)
    {
        public string Name { get; } = Name;
        public PropertyType Type { get; } = Type;
        public string ArgumentType { get; } = ArgumentType;
        public Accessibility Accessibility { get; } = Accessibility;
        public bool AsNoTracking { get; } = AsNoTracking;
    }

    private enum PropertyType
    {
        // ReSharper disable InconsistentNaming
        DbSet = 0,
        IQueryable = 1,
    }

    private enum ServiceLifetime
    {
        Singleton,
        Scoped,
        Transient,
    }
}
